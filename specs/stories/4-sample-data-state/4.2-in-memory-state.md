### User Story 4.2

**Number:** `4.2`
**ID:** `BA-US-in-memory-state`
**Role:** `player`
**Story:** `As a player, I want the game to remember which event I've selected and which trigger is active so that the UI reflects my current interaction state as I explore the timeline.`

**Context / Background:**
- State management ensures the UI is consistent and responsive
- For MVP, state is in-memory only (no persistence)
- Key state includes: selected event ID, active trigger, hover preview state
- State updates drive UI changes (highlight selected dot, show active trigger, load right panel content)

**Functional Requirements:**
1. Maintain in-memory state for the currently selected event (event ID or null if none selected)
2. Maintain in-memory state for the currently active trigger (trigger name or null if none active)
3. Maintain in-memory state for hover preview (hovered event ID or null if not hovering)
4. Update state when player interacts with the arc (hover, click) or card (click trigger)
5. Provide state to rendering components so they can reflect the current state

**Non-Functional / UX Requirements:**
- State updates should be immediate (no lag or delay)
- State should be consistent across all UI components (arc, left column, right column)
- State should reset to default when the page is refreshed (no persistence)
- State management should be simple and maintainable for MVP

**Data & State:**
- Inputs: User interactions (hover, click events)
- Outputs: Updated state object (e.g., `{selectedEventId, activeTrigger, hoveredEventId}`)
- State rules:
  - Only one event can be selected at a time
  - Only one trigger can be active at a time
  - Hovering an event doesn't change the selected event (just shows preview)
  - Clicking an event updates selectedEventId and clears activeTrigger (until a trigger is clicked)

**Validation & Edge Cases:**
- Selecting an event that doesn't exist: log error, do not update state
- Activating a trigger that doesn't exist for the current event: log error, do not update state
- Rapid clicks: ensure state updates in correct order (last click wins)
- State corruption: validate state shape before updates

**Assumptions:**
- State is managed using a simple JavaScript object or state management library (e.g., React useState/useContext, Svelte stores, or vanilla JS)
- No need for complex state management (Redux, MobX) for MVP
- State does not need to be serialized or persisted
- No undo/redo functionality needed

**Out of Scope (for this story):**
- State persistence (localStorage, cookies, backend)
- State history or undo/redo
- Complex state transitions or animations
- Multi-user state synchronization (multiplayer)

**Acceptance Criteria (Gherkin-style):**
- Given I click a dot on the arc, when the click registers, then the selectedEventId state is updated and the UI reflects the selected card in the left column
- Given I click a trigger button, when the click registers, then the activeTrigger state is updated and the right column displays the corresponding content
- Given I hover over a dot, when the hover is detected, then the hoveredEventId state is updated and the left column shows a preview card (desktop only)
- Given I refresh the page, when the game reloads, then the state resets to default (no event selected, no trigger active)
