### User Story 6.13

**Number:** `6.13`
**ID:** `BA-US-minigame-type-selection-logic`
**Role:** `system`
**Story:** `As the game system, I want to intelligently select the most appropriate mini-game type for each attacked event so that players experience variety, appropriate difficulty, and educational value when defending events.`

**Context / Background:**
- With five different mini-game types available, the system must decide which one to present for each attacked event
- Selection should consider event characteristics, content availability, difficulty progression, and variety
- The goal is to prevent repetitive gameplay while matching mini-game types to suitable events
- Educational goal: Different mini-game types reinforce different cognitive skills
- Game design goal: Maintain engagement through variety and appropriate challenge matching

**Functional Requirements:**
1. Implement a selection algorithm that chooses mini-game type based on multiple factors:
   - Event content characteristics (sequential nature, key terms, visual elements, etc.)
   - Event difficulty level
   - Event hierarchy level (top-level vs drill-down)
   - Player's recent mini-game history (to ensure variety)
   - Content availability (sufficient data to generate the mini-game)
2. Define mini-game type suitability for each event type:
   - **Chronological Sequence Puzzle:** Events with clear phases/stages (wars, expeditions, inventions with development timeline)
   - **Fact Matching:** Events with specific names, dates, locations, technical terms
   - **Spot the Anomaly:** Events with visual representations or detailed contextual descriptions
   - **Metadata Classification:** Events with clear categorical relationships or related/unrelated facts
   - **Cause-Effect Chain:** Events with identifiable causes and effects
   - **Multiple Choice Quiz:** Default fallback for any event (existing implementation)
3. Implement variety tracking:
   - Track last 3-5 mini-game types player encountered
   - Avoid selecting same type consecutively unless forced by content constraints
   - Prefer less-recently-used types when multiple types are suitable
4. Implement difficulty mapping:
   - Easy events (difficulty 1): Simple Quiz or Fact Matching (fewer elements)
   - Medium events (difficulty 2): All types available
   - Hard events (difficulty 3): Sequence Puzzle, Cause-Effect Chain, or Classification (more complex)
5. Implement content validation:
   - Check if event has sufficient data for selected mini-game type
   - If insufficient: fall back to next suitable type or default Quiz
6. Return selected mini-game type to defense initialization system
7. Log selection decisions for analytics and balancing

**Non-Functional / UX Requirements:**
- Selection algorithm must execute quickly (under 100ms) to avoid delay when loading defense
- Selection must be deterministic for same event in same conditions (player shouldn't see different mini-game on reload)
- Selection must feel fair (not always hardest type for every event)
- Variety mechanism should prevent seeing same mini-game type more than twice in a row
- Selection logic must be maintainable and easy to adjust for balancing
- Algorithm should gracefully handle edge cases (event with minimal content)

**Data & State:**
- Inputs:
  - Event ID
  - Event characteristics:
    - Difficulty level (1-3)
    - Hierarchy level (0-3)
    - Content structure (has sequential steps, has key terms, has visual description, etc.)
    - Era
    - Tags
  - Player's mini-game history (last 5 mini-game types encountered)
  - Available mini-game types and their requirements
- Outputs:
  - Selected mini-game type (enum: SEQUENCE, FACT_MATCH, ANOMALY, CLASSIFICATION, CAUSE_EFFECT, QUIZ)
  - Confidence score (how suitable is this type for this event)
  - Fallback type (if primary selection fails validation)
  - Selection rationale (for logging/debugging)
- State rules:
  - Selection is made when event enters "attacked" state
  - Selection is stored with the attack instance (same event attacked later may get different type)
  - Player's mini-game history is updated after each defense (success or failure)
  - If player has never defended before, history is empty (all types equally likely)

**Validation & Edge Cases:**
- Event has no content: default to simple Quiz with generic era questions
- Event is suitable for multiple mini-game types: use variety tracking to pick least-recently-used
- Event is suitable for no mini-game types except Quiz: use Quiz (safe fallback)
- Player's history is empty (first defense): randomly select from suitable types
- Player's history shows same type 3+ times in a row (edge case): force variety by excluding that type
- Event difficulty level is outside 1-3 range: treat as difficulty 2 (medium)
- Algorithm fails or crashes: safe fallback to Quiz
- Content validation fails for selected type: try next suitable type, ultimately fall back to Quiz
- Two events with identical characteristics: should get same type (deterministic)

**Assumptions:**
- Events have sufficient metadata (difficulty, hierarchy level, era, tags) for selection logic
- Player's mini-game history is tracked and stored in game state
- Each mini-game type has clear content requirements that can be programmatically checked
- Quiz type can always be generated for any event (safe universal fallback)
- Selection happens server-side or in a trusted environment (to prevent player manipulation)
- Event content is structured enough to enable automatic suitability detection
- Variety is important but not more important than content fit (don't force unsuitable types)

**Out of Scope (for this story):**
- Player preference/choice of mini-game type (system decides automatically)
- Dynamic difficulty adjustment based on player performance
- Adaptive learning that makes types easier/harder based on player skill
- A/B testing different selection algorithms
- Machine learning-based selection
- Manual override by content authors for specific events
- Time-of-day or session-length factors in selection
- Multiplayer coordination (different players seeing different types)

**Acceptance Criteria (Gherkin-style):**
- Given an event enters "attacked" state, when the system selects a mini-game type, then the selection completes in under 100ms
- Given an event has clear sequential phases, when mini-game type is selected, then Chronological Sequence Puzzle has high priority
- Given an event has many specific names and dates, when mini-game type is selected, then Fact Matching has high priority
- Given an event has visual description or context-rich content, when mini-game type is selected, then Spot the Anomaly has high priority
- Given an event has clear categorical relationships, when mini-game type is selected, then Metadata Classification has high priority
- Given an event has identifiable causes and effects, when mini-game type is selected, then Cause-Effect Chain has high priority
- Given player's last 2 defenses were Quiz type, when mini-game type is selected, then Quiz type is deprioritized unless it's the only suitable type
- Given player's history shows variety, when mini-game type is selected, then the least-recently-used suitable type is preferred
- Given an event has insufficient content for the selected type, when validation runs, then the system falls back to the next suitable type
- Given all specialized types fail validation, when selection finalizes, then Quiz type is selected as universal fallback
- Given the same event is attacked twice under same conditions, when mini-game type is selected both times, then the same type is selected (deterministic)
- Given an event has difficulty level 1, when mini-game type is selected, then simpler types (Quiz, Fact Matching) are preferred
- Given an event has difficulty level 3, when mini-game type is selected, then complex types (Sequence, Cause-Effect, Classification) are preferred

**Selection Algorithm Pseudocode:**

```
function selectMiniGameType(event, playerHistory):
  // Step 1: Determine suitability scores for each type
  suitabilityScores = {
    SEQUENCE: calculateSequenceSuitability(event),
    FACT_MATCH: calculateFactMatchSuitability(event),
    ANOMALY: calculateAnomalySuitability(event),
    CLASSIFICATION: calculateClassificationSuitability(event),
    CAUSE_EFFECT: calculateCauseEffectSuitability(event),
    QUIZ: 1.0  // Always suitable as fallback
  }

  // Step 2: Apply variety bonus (boost less-recently-used types)
  for each type in suitabilityScores:
    if type not in last 2 entries of playerHistory:
      suitabilityScores[type] *= 1.5  // Variety bonus
    if type appears 3+ times in playerHistory:
      suitabilityScores[type] *= 0.3  // Variety penalty

  // Step 3: Apply difficulty-based weighting
  if event.difficulty == 1:
    suitabilityScores[QUIZ] *= 1.2
    suitabilityScores[FACT_MATCH] *= 1.2
  else if event.difficulty == 3:
    suitabilityScores[SEQUENCE] *= 1.2
    suitabilityScores[CAUSE_EFFECT] *= 1.2
    suitabilityScores[CLASSIFICATION] *= 1.2

  // Step 4: Select type with highest score
  selectedType = type with max(suitabilityScores)

  // Step 5: Validate content availability
  if not validateContentFor(selectedType, event):
    // Remove selected type and try next best
    remove selectedType from suitabilityScores
    selectedType = type with max(remaining suitabilityScores)

  // Step 6: Return selection
  return selectedType
```

**Suitability Calculation Examples:**

```
function calculateSequenceSuitability(event):
  score = 0
  if event.content has "triggers.story.content" with multiple paragraphs:
    score += 0.3
  if event.tags includes "war", "exploration", "development":
    score += 0.4
  if event.funFacts > 3:
    score += 0.2
  if event.hierarchyLevel > 0:  // Drill-down events often have phases
    score += 0.1
  return min(score, 1.0)

function calculateFactMatchSuitability(event):
  score = 0
  if event has specific year:
    score += 0.2
  if event.title has proper nouns:
    score += 0.2
  if event.description has technical terms:
    score += 0.3
  if event.funFacts > 2:
    score += 0.2
  if event.tags includes "invention", "innovation", "science":
    score += 0.1
  return min(score, 1.0)

function calculateAnomalySuitability(event):
  score = 0
  if event.content has visual description:
    score += 0.5
  if event.era is specific (not "ancient" or "modern" broad categories):
    score += 0.2
  if event has detailed contextual content:
    score += 0.2
  if event.tags includes "culture", "art", "innovation":
    score += 0.1
  return min(score, 1.0)

function calculateClassificationSuitability(event):
  score = 0
  if event has related events (relatedEventIds):
    score += 0.4
  if event.funFacts > 3:
    score += 0.3
  if event.tags > 1:
    score += 0.2
  if event.hierarchyLevel == 0:  // Top-level events good for categorization
    score += 0.1
  return min(score, 1.0)

function calculateCauseEffectSuitability(event):
  score = 0
  if event.tags includes "war", "politics", "innovation":
    score += 0.4
  if event has related events:
    score += 0.3
  if event.difficulty >= 2:
    score += 0.2
  if event.content.story is long (multiple paragraphs):
    score += 0.1
  return min(score, 1.0)
```
